import { z } from "zod";
import { QueryService } from "../database/query-service.js";
import { ResultFormatter, QueryAnalyzer } from "../utils/query-utils.js";
import { OutputFormat } from "../types/database.js";

const queryService = new QueryService();

// Get Database Schema Tool
export const getDatabaseSchemaSchema = z.object({
  table_name: z.string().optional().describe("Specific table name to get schema for (optional)")
});

export async function getDatabaseSchema(args: z.infer<typeof getDatabaseSchemaSchema>): Promise<string> {
  try {
    const { table_name } = args;
    
    if (table_name) {
      const schemas = await queryService.getTableSchema(table_name);
      if (schemas.length === 0) {
        return `No table found with name '${table_name}'`;
      }
      
      const schema = schemas[0];
      let result = `Schema for table '${schema.tableName}':\n\n`;
      result += schema.columns.map(col => {
        const lengthPart = col.characterMaximumLength ? `(${col.characterMaximumLength})` : '';
        const nullPart = col.isNullable ? 'NULL' : 'NOT NULL';
        const defaultPart = col.columnDefault ? ` DEFAULT ${col.columnDefault}` : '';
        return `  ${col.columnName.padEnd(20)} | ${col.dataType}${lengthPart} | ${nullPart}${defaultPart}`;
      }).join('\n');
      
      return result;
    } else {
      const tables = await queryService.getTables();
      if (tables.length === 0) {
        return 'No tables found in the database.';
      }
      
      let result = 'Database tables:\n\n';
      result += 'table_name'.padEnd(20) + ' | ' + 'table_type'.padEnd(12) + ' | ' + 'table_schema\n';
      result += '-'.repeat(19) + '|' + '-'.repeat(13) + '|' + '-'.repeat(13) + '\n';
      result += tables.map(table => `${table.padEnd(19)} | ${'BASE TABLE'.padEnd(12)} | ${'public'.padEnd(12)}`).join('\n');
      
      return result;
    }
  } catch (error) {
    return `Error getting database schema: ${error instanceof Error ? error.message : String(error)}`;
  }
}

// Execute SQL Query Tool
export const executeSqlQuerySchema = z.object({
  query: z.string().describe("The SQL query to execute"),
  params: z.array(z.union([z.string(), z.number(), z.boolean(), z.null()])).optional().describe("Query parameters for prepared statements"),
  format: z.enum(["table", "json", "csv"]).default("table").describe("Output format for results")
});

export async function executeSqlQuery(args: z.infer<typeof executeSqlQuerySchema>): Promise<string> {
  try {
    const { query, params = [], format } = args;
    
    // Basic safety check
    if (!QueryAnalyzer.isSafeQuery(query)) {
      return "Error: Only SELECT queries are allowed for safety reasons.";
    }
    
    const result = await queryService.executeRawQuery(query, params);
    
    let response = "Query executed successfully!\n\n";
    response += `Rows affected: ${result.rowCount}\n\n`;
    response += "Results:\n";
    response += ResultFormatter.format(result, format as OutputFormat);
    
    return response;
  } catch (error) {
    return `Error executing query: ${error instanceof Error ? error.message : String(error)}`;
  }
}

// Execute AI Generated SQL Tool
export const executeAiGeneratedSqlSchema = z.object({
  sql_query: z.string().describe("The SQL query generated by AI to execute"),
  explanation: z.string().optional().describe("Brief explanation of what the query does"),
  format: z.enum(["table", "json", "csv"]).default("table").describe("Output format for results")
});

export async function executeAiGeneratedSql(args: z.infer<typeof executeAiGeneratedSqlSchema>): Promise<string> {
  try {
    const { sql_query, explanation, format } = args;
    
    // Basic safety check
    if (!QueryAnalyzer.isSafeQuery(sql_query)) {
      return "Error: Only SELECT queries are allowed for safety reasons.";
    }
    
    const result = await queryService.executeRawQuery(sql_query);
    
    let response = "AI-Generated SQL Query Executed Successfully!\n\n";
    if (explanation) {
      response += `Explanation: ${explanation}\n\n`;
    }
    response += `Query: ${sql_query}\n\n`;
    response += `Rows returned: ${result.rowCount}\n\n`;
    response += "Results:\n";
    response += ResultFormatter.format(result, format as OutputFormat);
    
    return response;
  } catch (error) {
    return `Error executing AI-generated query: ${error instanceof Error ? error.message : String(error)}`;
  }
}

// Natural Language Query Tool
export const naturalLanguageQuerySchema = z.object({
  question: z.string().describe("Natural language question about the data"),
  suggested_tables: z.array(z.string()).optional().describe("Tables that might be relevant to the query"),
  format: z.enum(["table", "json", "csv"]).default("table").describe("Output format for results")
});

export async function naturalLanguageQuery(args: z.infer<typeof naturalLanguageQuerySchema>): Promise<string> {
  try {
    const { question, suggested_tables } = args;
    
    // Get schema context
    const schemaContext = await queryService.getSchemaContext(suggested_tables);
    
    // Generate suggestions based on the question
    const suggestions = QueryAnalyzer.getQuerySuggestions(question.toLowerCase());
    
    let response = `Natural Language Query Analysis\n\n`;
    response += `Question: ${question}\n\n`;
    response += `Available Schema Context:\n${schemaContext}\n\n`;
    
    if (suggestions.length > 0) {
      response += `Query Suggestions:\n`;
      response += suggestions.join('\n') + '\n\n';
    }
    
    response += `To execute a specific query, please use the 'execute_sql_query' tool with your SQL statement.`;
    
    return response;
  } catch (error) {
    return `Error processing natural language query: ${error instanceof Error ? error.message : String(error)}`;
  }
}
